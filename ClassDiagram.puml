@startuml
top to bottom direction
skinparam linetype ortho

' ===== Model Hierarchy =====
abstract class ModelBase {
    +ModelBase(double initValue)
    +ModelBase(const ModelBase& model)
    +ModelBase& operator=(const ModelBase& model)
    +virtual ~ModelBase() = default
    +double initValue() const
    #double _initValue
}

abstract class Model1D {
    +Model1D(double initValue)
    +virtual ~Model1D() = default
    +virtual double drift(double time, double assetPrice) const = 0
    +virtual double diffusion(double time, double assetPrice) const = 0
    +virtual Model1D* clone() const = 0
    +virtual bool operator==(const Model1D& model) const = 0
}

abstract class Model2D {
    +Model2D(double initValue)
    +virtual ~Model2D() = default
    +virtual pair<double, double> drift2D(double time, double assetPrice, double auxVariable) const = 0
    +virtual pair<double, double> diffusion2D(double time, double assetPrice, double auxVariable) const = 0
    +virtual Model2D* clone() const = 0
    +virtual bool operator==(const Model2D& model) const = 0
    +virtual double correlation() const = 0
}

class BlackScholesModel {
    +BlackScholesModel(double spot, const DiscountCurve& discountCurve, double sigma)
    +BlackScholesModel(const BlackScholesModel& model)
    +BlackScholesModel* clone() const override
    +BlackScholesModel& operator=(const BlackScholesModel& model)
    +bool operator==(const Model1D& model) const override
    +double drift(double time, double assetPrice) const override
    +double diffusion(double time, double assetPrice) const override
    +double drift() const
    +double volatility() const
    -double _drift
    -double _volatility
}

class DupireModel {
    +DupireModel(double spot, const VolatilitySurface& volSurface)
    +DupireModel(const DupireModel& model)
    +DupireModel* clone() const override
    +DupireModel& operator=(const DupireModel& model)
    +bool operator==(const Model1D& model) const override
    +double drift(double time, double assetPrice) const override
    +double diffusion(double time, double assetPrice) const override
    +const VolatilitySurface& volatilitySurface() const
    +double localVolatility(double spot, double time) const
    -unique_ptr<const VolatilitySurface> _volSurfacePtr
}

class HestonModel {
    +HestonModel(double spot, const DiscountCurve& discountCurve, double v0, double kappa, double vbar, double sigma_v, double rho)
    +HestonModel(const HestonModel& model)
    +HestonModel* clone() const override
    +HestonModel& operator=(const HestonModel& model)
    +bool operator==(const Model2D& model) const override
    +pair<double, double> drift2D(double time, double assetPrice, double variance) const override
    +pair<double, double> diffusion2D(double time, double assetPrice, double variance) const override
    +double correlation() const override
    +double v0() const
    +double kappa() const
    +double vbar() const
    +double sigma_v() const
    +double rho() const
    +double riskFreeRate() const
    +bool satisfiesFellerCondition() const
    -double _riskFreeRate
    -double _v0
    -double _kappa
    -double _vbar
    -double _sigma_v
    -double _rho
}

ModelBase <|-- Model1D
ModelBase <|-- Model2D
Model1D <|-- BlackScholesModel
Model1D <|-- DupireModel
Model2D <|-- HestonModel

' Force vertical stacking for Model group
ModelBase -[hidden]down- Model1D
Model1D -[hidden]down- BlackScholesModel
BlackScholesModel -[hidden]down- DupireModel
Model2D -[hidden]down- HestonModel

' ===== Financial Instrument Hierarchy =====
abstract class FinancialInstrument {
    +virtual FinancialInstrument* clone() const = 0
    +virtual ~FinancialInstrument() = default
}

abstract class Option {
    +enum class Type { Call, Put }
    +explicit Option(Option::Type type)
    +Option() = default
    +virtual Type type() const = 0
    +virtual Option* clone() const override = 0
    #Type _type
}

class EuropeanOptionPayoff {
    +EuropeanOptionPayoff(Type type)
    +EuropeanOptionPayoff(Type type, double strike, double maturity)
    +Option::Type type() const override
    +EuropeanOptionPayoff* clone() const override
    +virtual double strike() const
    +virtual double maturity() const
    -double _strike
    -double _maturity
}

class AmericanOption {
    ' TODO: Implementation pending
    ' Will use finite difference methods
}

FinancialInstrument <|-- Option
Option <|-- EuropeanOptionPayoff
Option <|-- AmericanOption

' Force vertical stacking for FinancialInstrument group
FinancialInstrument -[hidden]down- Option
Option -[hidden]down- EuropeanOptionPayoff
EuropeanOptionPayoff -[hidden]down- AmericanOption

' ===== Discount Curve Hierarchy =====
abstract class DiscountCurve {
    +virtual double discount(double time) const = 0
    +virtual DiscountCurve* clone() const = 0
    +virtual double rate() const = 0
    +virtual double instantaneousRate(double time, double eps) const
    +virtual ~DiscountCurve() = default
}

class FlatDiscountCurve {
    +FlatDiscountCurve(double rate)
    +double discount(double time) const override
    +double rate() const override
    +double instantaneousRate(double time, double eps) const override
    +FlatDiscountCurve* clone() const override
    -double _rate
}

FlatDiscountCurve --|> DiscountCurve

' ===== Interpolation Schemes Hierarchy =====
abstract class InterpolationScheme {
    +InterpolationScheme(const vector<double>& xData, const vector<double>& yData, ExtrapolationType extraType)
    +virtual ~InterpolationScheme() = default
    +virtual double interpolate(double x) const = 0
    +virtual double derivative(double x) const = 0
    +virtual double secondDerivative(double x) const = 0
    +virtual unique_ptr<InterpolationScheme> clone() const = 0
    +double operator()(double x) const
    +pair<double, double> getRange() const
    #vector<double> _xData, _yData
    #unique_ptr<ExtrapolationScheme> _extrapolationScheme
    #ExtrapolationType _extrapolationType
    #void validateData() const
    #size_t findInterval(double x) const
}

class LinearInterpolation {
    +LinearInterpolation(const vector<double>& xData, const vector<double>& yData, ExtrapolationType extraType)
    +double interpolate(double x) const override
    +double derivative(double x) const override
    +double secondDerivative(double x) const override
    +unique_ptr<InterpolationScheme> clone() const override
}

class CubicSplineInterpolation {
    +enum class BoundaryType { Natural, Clamped, Periodic }
    +CubicSplineInterpolation(const vector<double>& xData, const vector<double>& yData, BoundaryType boundaryType, ExtrapolationType extraType)
    +double interpolate(double x) const override
    +double derivative(double x) const override
    +double secondDerivative(double x) const override
    +unique_ptr<InterpolationScheme> clone() const override
    -BoundaryType _boundaryType
    -vector<double> _alpha, _beta, _gamma, _delta
    -void computeSplineCoefficients()
    -void solveThomasAlgorithm()
}

' ===== Extrapolation Schemes Hierarchy =====
abstract class ExtrapolationScheme {
    +virtual ~ExtrapolationScheme() = default
    +virtual unique_ptr<ExtrapolationScheme> clone() const = 0
    +virtual void initialize(const InterpolationScheme& interp) = 0
    +virtual double extrapolate(double x, const InterpolationScheme& interp) const = 0
}

class FlatExtrapolation {
    +unique_ptr<ExtrapolationScheme> clone() const override
    +void initialize(const InterpolationScheme& interp) override
    +double extrapolate(double x, const InterpolationScheme& interp) const override
    -double _yMin, _yMax
}

class LinearExtrapolation {
    +unique_ptr<ExtrapolationScheme> clone() const override
    +void initialize(const InterpolationScheme& interp) override
    +double extrapolate(double x, const InterpolationScheme& interp) const override
    -double _yMin, _yMax
    -double _dyMin, _dyMax
}

class QuadraticExtrapolation {
    +unique_ptr<ExtrapolationScheme> clone() const override
    +void initialize(const InterpolationScheme& interp) override
    +double extrapolate(double x, const InterpolationScheme& interp) const override
    -double _yMin, _yMax
    -double _dyMin, _dyMax
    -double _d2yMin, _d2yMax
}

LinearInterpolation --|> InterpolationScheme
CubicSplineInterpolation --|> InterpolationScheme
FlatExtrapolation --|> ExtrapolationScheme
LinearExtrapolation --|> ExtrapolationScheme
QuadraticExtrapolation --|> ExtrapolationScheme

' Force vertical stacking for InterpolationScheme group
InterpolationScheme -[hidden]down- LinearInterpolation
LinearInterpolation -[hidden]down- CubicSplineInterpolation
ExtrapolationScheme -[hidden]down- FlatExtrapolation
FlatExtrapolation -[hidden]down- LinearExtrapolation
LinearExtrapolation -[hidden]down- QuadraticExtrapolation

' ===== Volatility Surface Classes =====
class VolatilitySurface {
    +enum class SmileInterpolationType { Linear, CubicSpline }
    +enum class MaturityInterpolationType { Bilinear, ForwardMoneyness }
    +VolatilitySurface(const vector<double>& strikes, const vector<double>& maturities, const vector<vector<double>>& volatilities, const DiscountCurve& discountCurve, SmileInterpolationType smileInterpolationType, MaturityInterpolationType maturityInterpolationType)
    +double impliedVolatility(double strike, double maturity) const
    +double localVolatility(double spot, double time) const
    +pair<pair<double, double>, pair<double, double>> getBounds() const
    +unique_ptr<VolatilitySurface> clone() const
    +bool operator==(const VolatilitySurface& other) const
    +const vector<double>& strikes() const
    +const vector<double>& maturities() const
    +const vector<vector<double>>& volatilities() const
    +const DiscountCurve& discountCurve() const
    -vector<double> _strikes
    -vector<double> _maturities
    -vector<vector<double>> _volatilities
    -SmileInterpolationType _smileInterpolationType
    -MaturityInterpolationType _maturityInterpolationType
    -unique_ptr<DiscountCurve> _discountCurve
    -vector<unique_ptr<InterpolationScheme>> _smileInterpolators
    -vector<unique_ptr<InterpolationScheme>> _termStructureInterpolators
    -void validateInputData() const
    -void initializeInterpolators()
    -double computeDupireLocalVolatility(double spot, double time) const
    -double impliedVolatilityBilinear(double strike, double maturity) const
    -double impliedVolatilityForwardMoneyness(double strike, double maturity) const
    -double impliedVolatilityDerivativeTime(double strike, double maturity) const
    -double impliedVolatilityDerivativeStrike(double strike, double maturity) const
    -double impliedVolatilitySecondDerivativeStrike(double strike, double maturity) const
}

class VolatilitySurfaceBuilder {
    +VolatilitySurfaceBuilder& addStrike(double strike)
    +VolatilitySurfaceBuilder& addMaturity(double maturity)
    +VolatilitySurfaceBuilder& setVolatility(double strike, double maturity, double volatility)
    +VolatilitySurfaceBuilder& setSmileInterpolationType(VolatilitySurface::SmileInterpolationType type)
    +VolatilitySurfaceBuilder& setMaturityInterpolationType(VolatilitySurface::MaturityInterpolationType type)
    +VolatilitySurfaceBuilder& setDiscountCurve(const DiscountCurve& discountCurve)
    +unique_ptr<VolatilitySurface> build()
    -vector<double> _strikes
    -vector<double> _maturities
    -vector<vector<double>> _volatilities
    -map<pair<double, double>, double> _volatilityMap
    -VolatilitySurface::SmileInterpolationType _smileInterpolationType
    -VolatilitySurface::MaturityInterpolationType _maturityInterpolationType
    -unique_ptr<DiscountCurve> _discountCurve
    -void sortAndDeduplicate()
    -void buildVolatilityMatrix()
}

' ===== Pricing Method Hierarchy =====
abstract class Pricer {
    +Pricer() = default
    +Pricer(const Model1D& model, const DiscountCurve& discountCurve)
    +virtual Pricer* clone() const = 0
    +virtual ~Pricer()
    +virtual double price(const EuropeanOptionPayoff& option) const = 0
    #const Model1D* _modelPtr
    #const DiscountCurve* _discountCurvePtr
}

class BlackScholesPricer {
    +BlackScholesPricer()
    +BlackScholesPricer(const BlackScholesModel& model, const DiscountCurve& discountCurve)
    +BlackScholesPricer* clone() const override
    +double price(const EuropeanOptionPayoff& option) const override
    #const BlackScholesModel* _bsModelPtr
}

class MonteCarloPricer {
    +MonteCarloPricer() = default
    +MonteCarloPricer(const Model1D& model, const DiscountCurve& discountCurve, const PathSimulator& simulator, size_t numPaths)
    +MonteCarloPricer* clone() const override
    +double price(const EuropeanOptionPayoff& option) const override
    #size_t _numPaths
    #const PathSimulator* _simulatorPtr
}

class FDPricer {
    +FDPricer(const Model1D& model, const DiscountCurve& discountCurve, double S_min, double S_max, size_t N_S, size_t N_t)
    +FDPricer(const FDPricer& other)
    +FDPricer* clone() const override
    +double price(const EuropeanOptionPayoff& option) const override
    +double delta(const EuropeanOptionPayoff& option) const
    +double gamma(const EuropeanOptionPayoff& option) const
    #unique_ptr<Grid> _grid
    #unique_ptr<ThetaMethodSolver> createSolver(const EuropeanOptionPayoff& option) const
}

BlackScholesPricer --|> Pricer
MonteCarloPricer --|> Pricer
FDPricer --|> Pricer

' Force vertical stacking for Pricer group
Pricer -[hidden]down- BlackScholesPricer
BlackScholesPricer -[hidden]down- MonteCarloPricer
MonteCarloPricer -[hidden]down- FDPricer

' ===== Path Simulator Hierarchy (1D) =====
class PathSimulator {
    +PathSimulator(const vector<double>& timeSteps, const Model1D& model, size_t randomSeed)
    +virtual ~PathSimulator()
    +vector<double> path() const
    +virtual double nextStep(size_t timeIndex, double assetPrice) const = 0
    +const vector<double>& timeSteps() const
    #bool timeStepsSanityCheck() const
    #vector<double> _timeSteps
    #const Model1D* _modelPtr
    #mutable default_random_engine _randomEngine
}

class EulerPathSimulator {
    +EulerPathSimulator(const vector<double>& timeSteps, const Model1D& model, size_t randomSeed)
    +double nextStep(size_t timeIndex, double assetPrice) const override
}

class MilsteinPathSimulator {
    +MilsteinPathSimulator(const vector<double>& timeSteps, const Model1D& model, size_t randomSeed)
    +double nextStep(size_t timeIndex, double assetPrice) const override
}

' ===== Path Simulator Hierarchy (2D) =====
class PathSimulator2D {
    +PathSimulator2D(const vector<double>& timeSteps, const Model2D& model, size_t randomSeed)
    +virtual ~PathSimulator2D()
    +pair<vector<double>, vector<double>> paths() const
    +virtual pair<double, double> nextStep(size_t timeIndex, double assetPrice, double variance) const = 0
    #bool timeStepsSanityCheck() const
    #pair<double, double> generateCorrelatedNormals() const
    #double stepLogPriceEq33(double X_t, double V_t, double V_next, double dt, double Z, double gamma1, double gamma2) const
    #const vector<double>& _timeSteps
    #const Model2D* _modelPtr
    #size_t _randomSeed
    #mutable default_random_engine _randomEngine
}

class EulerPathSimulator2D {
    +EulerPathSimulator2D(const vector<double>& timeSteps, const Model2D& model, size_t randomSeed)
    +pair<double, double> nextStep(size_t timeIndex, double assetPrice, double variance) const override
}

class MilsteinPathSimulator2D {
}

class BKPathSimulator2D {
    +BKPathSimulator2D(const vector<double>& timeSteps, const Model2D& model, size_t randomSeed, NewtonMethod newtonMethod)
    +pair<double, double> nextStep(size_t timeIndex, double assetPrice, double variance) const override
    #NewtonMethod _newtonMethod
}

class TGPathSimulator2D {
    +TGPathSimulator2D(const vector<double>& timeSteps, const Model2D& model, size_t randomSeed, double gamma1, double gamma2)
    +pair<double, double> nextStep(size_t timeIndex, double assetPrice, double variance) const override
    #double _gamma1
    #double _gamma2
    -double stepVarianceTG(double V_t, double dt, double Z_V) const
}

class QEPathSimulator2D {
    +QEPathSimulator2D(const vector<double>& timeSteps, const Model2D& model, size_t randomSeed, double psi_c, double gamma1, double gamma2)
    +pair<double, double> nextStep(size_t timeIndex, double assetPrice, double variance) const override
    #double _psi_c
    #double _gamma1
    #double _gamma2
    -double stepVarianceQE(double V_t, double dt, double Z_V) const
}

EulerPathSimulator --|> PathSimulator
MilsteinPathSimulator --|> PathSimulator
EulerPathSimulator2D --|> PathSimulator2D
MilsteinPathSimulator2D --|> PathSimulator2D
BKPathSimulator2D --|> PathSimulator2D
TGPathSimulator2D --|> PathSimulator2D
QEPathSimulator2D --|> PathSimulator2D

' Force vertical stacking for PathSimulator group
PathSimulator -[hidden]down- EulerPathSimulator
EulerPathSimulator -[hidden]down- MilsteinPathSimulator
PathSimulator2D -[hidden]down- EulerPathSimulator2D
EulerPathSimulator2D -[hidden]down- BKPathSimulator2D
BKPathSimulator2D -[hidden]down- TGPathSimulator2D
TGPathSimulator2D -[hidden]down- QEPathSimulator2D

' ===== PDE Components =====
abstract class PDE {
    +virtual ~PDE() = default
    +virtual double diffusion(double x, double t) const = 0
    +virtual double convection(double x, double t) const = 0
    +virtual double reaction(double x, double t) const = 0
    +virtual double source(double x, double t) const = 0
    +virtual double initialCondition(double x) const = 0
    +virtual PDE* clone() const = 0
}

class ConstantCoefficientPDE {
    +ConstantCoefficientPDE(double a, double b, double c, double d, function<double(double)> initialCond)
    +double diffusion(double x, double t) const override
    +double convection(double x, double t) const override
    +double reaction(double x, double t) const override
    +double source(double x, double t) const override
    +double initialCondition(double x) const override
    +ConstantCoefficientPDE* clone() const override
    -double _a, _b, _c, _d
    -function<double(double)> _u0
}

class VariableCoefficientPDE {
    +VariableCoefficientPDE(function<double(double, double)> diffusion_fn, function<double(double, double)> convection_fn, function<double(double, double)> reaction_fn, function<double(double, double)> source_fn, function<double(double)> initialCond)
    +double diffusion(double x, double t) const override
    +double convection(double x, double t) const override
    +double reaction(double x, double t) const override
    +double source(double x, double t) const override
    +double initialCondition(double x) const override
    +VariableCoefficientPDE* clone() const override
    -function<double(double, double)> _a_fn, _b_fn, _c_fn, _d_fn
    -function<double(double)> _u0
}

class Grid {
    +enum class SpacingType { Uniform, LogSpaced }
    +Grid(double S_min, double S_max, size_t N_S, double T_max, size_t N_t, SpacingType spacingType)
    +Grid* clone() const
    +double spotMin() const
    +double spotMax() const
    +double timeMax() const
    +size_t numSpotPoints() const
    +size_t numTimeSteps() const
    +SpacingType spacingType() const
    +const vector<double>& spots() const
    +const vector<double>& times() const
    +double spot(size_t i) const
    +double time(size_t j) const
    +double dt() const
    +double dS(size_t i) const
    +double dS_forward(size_t i) const
    +double dS_backward(size_t i) const
    +pair<pair<double, double>, pair<double, double>> getBounds() const
    -double _S_min, _S_max, _T_max, _dt
    -size_t _N_S, _N_t
    -SpacingType _spacingType
    -vector<double> _spotGrid, _timeGrid
    -void constructUniformGrid()
    -void constructLogSpacedGrid()
    -void constructTimeGrid()
    -void validateParameters() const
}

abstract class BoundaryCondition {
    +virtual ~BoundaryCondition() = default
    +virtual double lowerValue(double t) const = 0
    +virtual double upperValue(double t) const = 0
    +virtual BoundaryCondition* clone() const = 0
}

class DirichletBC {
    +DirichletBC(function<double(double)> lowerFunc, function<double(double)> upperFunc)
    +DirichletBC(double lowerValue, double upperValue)
    +double lowerValue(double t) const override
    +double upperValue(double t) const override
    +DirichletBC* clone() const override
    -function<double(double)> _lowerFunc, _upperFunc
}

abstract class Solver {
    +Solver(const PDE& pde, const Grid& grid, const BoundaryCondition& bc)
    +virtual ~Solver()
    +virtual vector<double> solve() = 0
    +const Grid& grid() const
    +const PDE& pde() const
    +const BoundaryCondition& boundaryCondition() const
    +const vector<double>& solution() const
    +double valueAt(double x) const
    +double derivativeAt(double x) const
    +double secondDerivativeAt(double x) const
    #unique_ptr<PDE> _pde
    #unique_ptr<Grid> _grid
    #unique_ptr<BoundaryCondition> _bc
    #vector<double> _solution
    #mutable unique_ptr<CubicSplineInterpolation> _interpolator
    #vector<double> computeInitialCondition() const
    #void applyBoundaryConditions(vector<double>& u, double t) const
    #const CubicSplineInterpolation& getInterpolator() const
    #size_t findGridIndex(double x) const
}

class ThetaMethodSolver {
    +enum class Scheme { Explicit, Implicit, CrankNicolson }
    +ThetaMethodSolver(const PDE& pde, const Grid& grid, const BoundaryCondition& bc, Scheme scheme)
    +vector<double> solve() override
    +double theta() const
    +Scheme scheme() const
    -double _theta
    -Scheme _scheme
    -void checkStability() const
    -vector<double> timeStep(const vector<double>& u_old, double t_old, double t_new)
}

struct GreekResults {
    double value
    double delta
    double gamma
    double vega
    double theta
    double rho
    double vanna
    double volga
}

class PDEGreeksCalculator {
    +using PDEFactory = function<unique_ptr<PDE>(double sigma, double r)>
    +PDEGreeksCalculator(const PDE& pde, const Grid& grid, const BoundaryCondition& bc, double sigma_base, double r_base, ThetaMethodSolver::Scheme scheme)
    +void solve(double spot)
    +GreekResults computeAllGreeks(const PDEFactory& pdeFactory) const
    +double delta() const
    +double gamma() const
    +double vega(const PDEFactory& pdeFactory) const
    +double rho(const PDEFactory& pdeFactory) const
    +double vanna(const PDEFactory& pdeFactory) const
    +double volga(const PDEFactory& pdeFactory) const
    +double theta() const
    +double value() const
    +bool isSolved() const
    -unique_ptr<Grid> _grid
    -unique_ptr<BoundaryCondition> _bc
    -ThetaMethodSolver::Scheme _scheme
    -double _sigma_base, _r_base, _spot
    -bool _solved
    -mutable unique_ptr<ThetaMethodSolver> _base_solver
    -double solvePDEAt(const PDE& pde, double spot) const
    -double solvePDEDelta(const PDE& pde, double spot) const
    -unique_ptr<Grid> createScaledGrid(double sigma) const
}

PDE <|-- ConstantCoefficientPDE
PDE <|-- VariableCoefficientPDE
BoundaryCondition <|-- DirichletBC
Solver <|-- ThetaMethodSolver

' Force vertical stacking for PDE group
PDE -[hidden]down- ConstantCoefficientPDE
ConstantCoefficientPDE -[hidden]down- VariableCoefficientPDE
BoundaryCondition -[hidden]down- DirichletBC
Solver -[hidden]down- ThetaMethodSolver

' ===== Utils and Helper Classes =====
class Utils {
    +static double stdNormCdf(double x)
    +static double stdNormPdf(double x)
    +static complex<double> stdNormChF(double omega)
    +static double inverseNormalCDF(double u)
}

class ThomasAlgorithm {
    +static vector<double> solve(const vector<double>& lower, const vector<double>& diag, const vector<double>& upper, const vector<double>& rhs)
}

class NumericalDerivatives {
    +static double firstDerivative(function<double(double)> f, double x, double h)
    +static double secondDerivative(function<double(double)> f, double x, double h)
}

class COSMethod {
    +struct Coefficients { vector<double> F_k; vector<double> omega; double a, b; size_t N; }
    +static Coefficients precomputeCoefficients(double a, double b, size_t N, const function<complex<double>(double)>& chf)
    +static double evaluateCDF(const Coefficients& coeffs, double x)
    +static double evaluatePDF(const Coefficients& coeffs, double x)
    +static vector<double> recoverCDF(double a, double b, size_t N, const function<complex<double>(double)>& chf, const vector<double>& x)
    +static vector<double> recoverPDF(double a, double b, size_t N, const function<complex<double>(double)>& chf, const vector<double>& x)
    +static pair<double, size_t> invertCDF(double a, double b, size_t N, const function<complex<double>(double)>& chf, double p, size_t max_iter, double tol)
    +static pair<double, size_t> invertCDF_Optimized(double a, double b, size_t N, const function<complex<double>(double)>& chf, double p, size_t max_iter, double tol)
}

class CIRSampler {
    +static double sampleCIR(double kappa, double vbar, double sigma, double v_s, double s, double t, default_random_engine& randomEngine)
}

class ChFIntegratedVariance {
    +static complex<double> compute(double omega, double kappa, double vbar, double sigma, double v_s, double v_t, double tau)
    -static complex<double> modifiedBesselI(double nu, complex<double> z)
}

class BlackScholesFormulas {
    +static double d1(double spot, double strike, double rate, double volatility, double maturity)
    +static double d2(double spot, double strike, double rate, double volatility, double maturity)
    +static double d1(double spot, double strike, const DiscountCurve& discountCurve, double volatility, double maturity)
    +static double d2(double spot, double strike, const DiscountCurve& discountCurve, double volatility, double maturity)
    +static double price(double spot, double strike, double rate, double volatility, double maturity, Option::Type optionType)
    +static double callPrice(double spot, double strike, double rate, double volatility, double maturity)
    +static double putPrice(double spot, double strike, double rate, double volatility, double maturity)
    +static double delta(double spot, double strike, double rate, double volatility, double maturity, Option::Type optionType)
    +static double vega(double spot, double strike, double rate, double volatility, double maturity)
    +static double theta(double spot, double strike, double rate, double volatility, double maturity, Option::Type optionType)
    +static double rho(double spot, double strike, double rate, double volatility, double maturity, Option::Type optionType)
    +static double gamma(double spot, double strike, double rate, double volatility, double maturity)
    +static double vanna(double spot, double strike, double rate, double volatility, double maturity)
    +static double volga(double spot, double strike, double rate, double volatility, double maturity)
}

' ===== Relationships between hierarchies =====
' Model relationships
Pricer --> Model1D : uses
PathSimulator --> Model1D : uses
PathSimulator2D --> Model2D : uses
BlackScholesModel --> DiscountCurve : uses
HestonModel --> DiscountCurve : uses
DupireModel --> VolatilitySurface : uses

' Pricer relationships
Pricer --> DiscountCurve : uses
MonteCarloPricer --> PathSimulator : uses
FDPricer --> Grid : uses
FDPricer --> ThetaMethodSolver : creates
BlackScholesPricer --> BlackScholesFormulas : uses

' PDE relationships
Solver --> PDE : uses
Solver --> Grid : uses
Solver --> BoundaryCondition : uses
Solver --> CubicSplineInterpolation : uses
PDEGreeksCalculator --> PDE : uses
PDEGreeksCalculator --> Grid : uses
PDEGreeksCalculator --> BoundaryCondition : uses
PDEGreeksCalculator --> ThetaMethodSolver : uses
PDEGreeksCalculator ..> GreekResults : creates

' Volatility Surface relationships
VolatilitySurface --> DiscountCurve : uses
VolatilitySurface --> InterpolationScheme : uses
VolatilitySurfaceBuilder --> DiscountCurve : uses
VolatilitySurfaceBuilder ..> VolatilitySurface : creates

' Interpolation relationships
InterpolationScheme --> ExtrapolationScheme : uses
CubicSplineInterpolation --> ThomasAlgorithm : uses

' PathSimulator2D relationships
BKPathSimulator2D --> COSMethod : uses
BKPathSimulator2D --> CIRSampler : uses
BKPathSimulator2D --> ChFIntegratedVariance : uses
TGPathSimulator2D --> CIRSampler : uses
QEPathSimulator2D --> CIRSampler : uses

' ===== Horizontal spacing between hierarchies =====
ModelBase -[hidden]right- FinancialInstrument
FinancialInstrument -[hidden]right- DiscountCurve
DiscountCurve -[hidden]right- InterpolationScheme
InterpolationScheme -[hidden]right- ExtrapolationScheme
ExtrapolationScheme -[hidden]right- VolatilitySurface
VolatilitySurface -[hidden]right- Pricer
Pricer -[hidden]right- PathSimulator
PathSimulator -[hidden]right- PathSimulator2D
PathSimulator2D -[hidden]right- PDE
PDE -[hidden]right- Grid
Grid -[hidden]right- BoundaryCondition
BoundaryCondition -[hidden]right- Solver
Solver -[hidden]right- PDEGreeksCalculator
PDEGreeksCalculator -[hidden]right- Utils
Utils -[hidden]right- BlackScholesFormulas

@enduml